Event video explanation at 13:54:51

yarn add --dev @chainlink/contracts

hardhat (hh) and autocomplete -> yarn global add hardhat-shorthand


it("picks a winner, resets the lottery and sends money", async () => {
                  const additionalEntrances = 3
                  const startingIndex = 2 // deployer = 0
                  const accounts = await ethers.getSigners()
                  for (let i = startingIndex; i < startingIndex + additionalEntrances; i++) {
                      const accountConnectedRaffle = raffle.connect(accounts[i])
                      await accountConnectedRaffle.enterRaffle({ value: entranceFee })
                  }
                  const startingTimeStamp = await raffle.getLatestTimeStamp()
                  // First we want to call performUpkeep (mock being Chainlink Keepers)
                  // then we want to call fulfillRandomWords (mock being Chainlink VRF)
                  // After both these things have happened we can record if:
                  //    - Recent winner get recorded?
                  //    - RaffleState, s_players and s_lastTimeStamp were reset
                  // To verify the above in a tesnet we will have to wait for fulfillRandoWords
                  // to be called, but in a local enviroment there's no need for that because
                  // we can adjust our blockchain to do whatever we want.
                  // BUT for this test we will simulate that we have to wait for that event to
                  // called as If we were in a tesnet. To achieve that we will need to set up an
                  // event listener.
                  // Basically we want the test to not finish until the listener has stopped listening
                  // so we need to create a new Promise
                  await new Promise(async (resolve, reject) => {
                      raffle.once("WinnerPicked", async () => {
                          // setting up the listener
                          console.log("WinnerPicked event fired!")
                          try {
                              const recentWinner = await raffle.getRecentWinner()
                              //console.log(recentWinner)
                              const raffleState = await raffle.getRaffleState()
                              const endingTimeStamp = await raffle.getLatestTimeStamp()
                              const numPlayers = await raffle.getNumberOfPlayers()
                              assert.equal(numPlayers.toString(), "0")
                              assert.equal(raffleState.toString(), "0")
                              assert(endingTimeStamp > startingTimeStamp)
                              resolve()
                          } catch (e) {
                              reject(e)
                          }
                      })

                      //below we will fire the event, and the event listener will pick it up and resolve
                      const tx = await raffle.performUpkeep("0x")
                      const txReceipt = await tx.wait(1)
                      // check inside VRFCoordinatorV2Mock to find fulfillRandomWords(params)
                      await vrfCoordinatorV2Mock.fulfillRandomWords(
                          txReceipt.events[1].args.requestId,
                          raffle.address
                      )
                  })
              })